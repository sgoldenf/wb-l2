package pattern

import (
	"errors"
	"fmt"
)

/*
	Реализовать паттерн «фабричный метод».
Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/Factory_method_pattern
*/

/*
	Фабричный метод — порождающий шаблон проектирования, предоставляющий подклассам (дочерним классам, субклассам) интерфейс для создания экземпляров некоторого класса.
	Другими словами, шаблон делегирует создание объектов наследникам родительского класса.

	Применимость:
	- Когда классу заранее неизвестно, объекты каких подклассов ему нужно создавать
	- Когда класс спроектирован так, чтобы объекты, которые он создаёт, специфицировались подклассами
	- Когда класс делегирует свои обязанности одному из нескольких вспомогательных подклассов
	Планируется локализовать знание о том, какой класс принимает эти обязанности на себя

	Плюсы и минусы:
	+ Позволяет сделать код создания объектов более универсальным, не привязываясь к конкретным классам (ConcreteProduct), а оперируя лишь общим интерфейсом (Product)
	+ Позволяет установить связь между параллельными иерархиями классов
	- Необходимость создавать наследника Creator для каждого нового типа продукта (ConcreteProduct)

	Примеры использования на практике:
	В рпг с множеством классов может быть фабрика персонажей с конкретными персонажами, имеющими определенный класс и соответствующими им конкретными фабриками
*/

type class string

const (
	// Fighter передается в фабричный метод для указания класса создаваемого персонажа.
	Fighter class = "Fighter"
	// Mage передается в фабричный метод для указания класса создаваемого персонажа.
	Mage class = "Mage"
)

// CreateCharacter - фабричный метод.
func CreateCharacter(c class) (Character, error) {
	switch c {
	case Fighter:
		return &fighterCharacter{}, nil
	case Mage:
		return &mageCharacter{}, nil
	}
	return nil, errors.New("not implemented")
}

// Character - продукт, определяющий общий интерфейс.
type Character interface {
	Attack()
}

type fighterCharacter struct{ Character }

// Attack для класса Fighter.
func (f *fighterCharacter) Attack() {
	fmt.Println("Attacking with my sword")
}

type mageCharacter struct{ Character }

// Attack для класса Mage.
func (m *mageCharacter) Attack() {
	fmt.Println("Attacking with my spells")
}
