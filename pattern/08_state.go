package pattern

import "fmt"

/*
	Реализовать паттерн «состояние».
Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/State_pattern
*/

/*
	Состояние — это поведенческий паттерн проектирования, который позволяет объектам менять поведение в зависимости от своего состояния

	Применимость:
	- Когда есть объект, поведение которого кардинально меняется в зависимости от внутреннего состояния, причём типов состояний много, и их код часто меняется.
	- Когда код класса содержит множество больших, похожих друг на друга, условных операторов, которые выбирают поведения в зависимости от текущих значений полей класса
	- Когда вы сознательно используете табличную машину состояний, построенную на условных операторах, но вынуждены мириться с дублированием кода для похожих состояний и переходов

	Плюсы и минусы:
	+ Избавляет от множества больших условных операторов машины состояний
	+ Концентрирует в одном месте код, связанный с определённым состоянием
	+ Упрощает код контекста
	- Может неоправданно усложнить код, если состояний мало и они редко меняются

	Примеры использования на практике:
	Клеточные автоматы для ИИ врагов в играх
*/

type state interface {
	Press()
}

type onState struct {
	ls *LightSwitch
}

// Press реализует метода переключения для onState.
func (s *onState) Press() {
	fmt.Println("Switching off")
	s.ls.setState(&offState{ls: s.ls})
}

type offState struct {
	ls *LightSwitch
}

// Press реализует метода переключения для offState.
func (s *offState) Press() {
	fmt.Println("Switching on")
	s.ls.setState(&onState{ls: s.ls})
}

// LightSwitch - контекст.
type LightSwitch struct {
	currentState state
}

// NewLightSwitch создает объект типа lightSwitch и возвращающая указатель на него.
func NewLightSwitch() *LightSwitch {
	ls := LightSwitch{}
	ls.setState(&offState{ls: &ls})
	return &ls
}

func (s *LightSwitch) setState(newState state) {
	s.currentState = newState
}
